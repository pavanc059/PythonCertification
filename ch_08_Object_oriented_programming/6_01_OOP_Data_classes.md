# Python Data Classes – Complete Course Notes

## Environment

- Code examples use **Python 3.9** (works on 3.7+).
- Demonstrated in the **bpython REPL** (enhanced REPL with color + completion).

---

# 1. Data Classes vs Regular Classes

## Creating a Data Class

```python
from dataclasses import dataclass

@dataclass
class Card:
    rank: str
    suit: str
````

### What You Get Automatically

Data classes generate:

* `__init__()`
* `__repr__()`
* `__eq__()`

You can:

* Instantiate objects
* Print them nicely
* Compare them

## Regular Class Comparison

A minimal regular class:

* Requires manually writing `__init__`
* Needs custom `__repr__`
* Needs custom `__eq__`
* More boilerplate
* Objects don’t compare equal unless manually implemented

**Conclusion:**
Data classes remove repetitive boilerplate and improve readability.

---

# 2. Alternatives to Data Classes

## Tuple

* Lightweight
* No named access
* Order-sensitive
* Easy to introduce subtle bugs

## Dictionary

* Named keys
* No attribute-style access
* Must maintain consistent keys

## namedtuple

* Named fields
* Behaves like tuple
* Immutable
* Hard to add defaults
* Can compare different namedtuple types unintentionally
* Good when tuple behavior is required

## attrs (Third-party)

* Inspired data classes
* Supports:

  * Validators
  * Converters
* Works on older Python versions
* External dependency

## Other Alternatives

* `typing.NamedTuple`
* `attrdict`
* `plumber`
* `fields`

**Takeaway:**
Data classes are best for most modern use cases, but alternatives still have niche advantages.

---

# 3. Basic Data Classes

Example:

```python
@dataclass
class Position:
    name: str
    lat: float
    lon: float
```

### Key Points

* Uses **variable annotations** (Python 3.6+).
* Type hints are required.
* Types are NOT enforced at runtime.
* Use `typing.Any` if needed.
* Type checkers (like mypy) catch errors statically.
* You can freely add custom methods.

Example: Add `.distance_to()` using the haversine formula.

---

# 4. Flexible Data Classes

You can customize behavior using:

* Parameters to `@dataclass`
* The `field()` function

Example:

```python
from dataclasses import field
```

Used for advanced customization.

---

# 5. Advanced Default Values

### ❌ Mutable Default Anti-Pattern

Never do this:

```python
cards: list = []
```

Problem:

* Shared across all instances.

### ✅ Use `default_factory`

```python
cards: list = field(default_factory=list)
```

* Accepts zero-argument callable.
* Creates new object per instance.

### field() Parameters

* `default`
* `default_factory`
* `init`
* `repr`
* `compare`
* `hash`
* `metadata`

Notes:

* Cannot use both `default` and `default_factory`.
* `metadata` stores extra info (not used by dataclasses directly).
* Use `fields()` to inspect metadata.

---

# 6. Representation

Two string representations:

## `__repr__()`

* Developer-friendly
* Should ideally recreate object
* Auto-generated by dataclasses

## `__str__()`

* User-friendly
* Not generated automatically

You can override either method.

Formatting note:

* `!s` in format strings forces `str()` usage.

---

# 7. Comparisons

Enable ordering:

```python
@dataclass(order=True)
class PlayingCard:
```

### Decorator Parameters

* `init=True`
* `repr=True`
* `eq=True`
* `order=False`
* `unsafe_hash=False`
* `frozen=False`

### How Ordering Works

Objects are compared as tuples of fields (in order defined).

If that’s not ideal:

* Add computed `sort_index`
* Use `__post_init__()`
* Exclude it from `init` and `repr` using `field()`

---

# 8. Immutable (Frozen) Data Classes

```python
@dataclass(frozen=True)
class Position:
```

* Fields cannot be reassigned.
* Raises exception on mutation.

⚠ Important:

* Nested mutable types (like lists) can still change.
* Use immutable types (e.g., tuple instead of list).

---

# 9. Inheritance

You can subclass data classes:

```python
@dataclass
class Capital(Position):
    country: str
```

### Rules

1. If base class has default fields,
   all new subclass fields must also have defaults.

2. Field order:

   * Base class fields first
   * Then subclass fields
   * Redefining field doesn’t change order

---

# 10. Optimizing with **slots**

Data classes are regular classes, so `__slots__` works.

Example:

```python
__slots__ = ("name", "lat", "lon")
```

### Benefits

* Reduced memory usage
* Faster attribute access (~20% faster in example)

### Restrictions

* Only listed attributes allowed
* Cannot have default values in slots class

---

# Final Summary

Data classes:

* Reduce boilerplate
* Provide automatic dunder methods
* Support type hints
* Allow default values and factories
* Support ordering and immutability
* Work with inheritance
* Can be optimized with `__slots__`

They are flexible, readable, and part of the standard library — making them the preferred modern way to build structured data objects in Python.

```

If you'd like, I can also generate:
- A condensed “exam revision” version (1–2 pages)
- A mind-map style version
- Or split this into multiple markdown files by topic
```
